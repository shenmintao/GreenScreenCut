#include <iostream>
#include <string>
#include <bgsegm.hpp>
#include "AlphaMatting.h"
#include "GlobalMatting.h"
#include "GuidedFilter.h"
using namespace cv;
//
//int main(int argc, const char * argv[]) {
//	cv::cuda::setDevice(0);
//	int cudaResult = cuda::getCudaEnabledDeviceCount();
//	SharedMatting sm;
//	Mat inMap = imread("E:\\Study\\图像处理\\代码\\AlphaMatting\\x64\\Debug\\Testset\\input.png");
//	Mat triMap = imread("E:\\Study\\图像处理\\代码\\AlphaMatting\\x64\\Debug\\Testset\\trimap.png");
//	sm.loadImage(inMap);
//	sm.loadTrimap(triMap);
//	sm.solveAlpha();
//	Mat alpha = sm.result();
//	Mat result;
//	vector<Mat> split;
//	cv::split(inMap, split);
//	cv::multiply(split[0], alpha/255.0, split[0]);
//	cv::multiply(split[1], alpha / 255.0, split[1]);
//	cv::multiply(split[2], alpha / 255.0, split[2]);
//	cv::merge(split, result);
//	imshow("result", result);
//	waitKey(0);
//	return 0;
//
//
//	//Mat frame; //current frame
//	//Mat fgMaskKNN; //fg mask fg mask generated by KNN method
//
//	//Ptr< BackgroundSubtractor> pKNN; //KNN Background subtractor
//	//VideoCapture stream("D:\\QQFiles\\459533652\\FileRecv\\s.mpg");
//	////create
//	//pKNN = createBackgroundSubtractorKNN();
//	//while (true) 
//	//{
//	//	Mat cameraFrame;
//	//	if (!(stream.read(frame))) //get one frame form video   
//	//		break;
//	//	pKNN->apply(frame, fgMaskKNN);
//	//	imshow("KNN", fgMaskKNN);
//	//	if (waitKey(30) >= 0)
//	//		break;
//	//}
//
//	//clock_t start, finish;
//	//omp_set_num_threads(8);
//	//start = clock();
//	//cv::Mat image = imread("E:\\Study\\图像处理\\代码\\AlphaMatting\\x64\\Debug\\Testset\\input.png",CV_LOAD_IMAGE_COLOR);
//	//cv::Mat trimap = imread("E:\\Study\\图像处理\\代码\\AlphaMatting\\x64\\Debug\\Testset\\trimap.png", CV_LOAD_IMAGE_GRAYSCALE);
//
//	//// (optional) exploit the affinity of neighboring pixels to reduce the 
//	//// size of the unknown region. please refer to the paper
//	//// 'Shared Sampling for Real-Time Alpha Matting'.
//	////expansionOfKnownRegions(image, trimap, 9);
//
//	//cv::Mat foreground, alpha;
//	//globalMatting(image, trimap, foreground, alpha);
//
//	//// filter the result with fast guided filter
//	//alpha = guidedFilter(image, alpha, 10, 1e-5);
//	//for (int x = 0; x < trimap.cols; ++x)
//	//	for (int y = 0; y < trimap.rows; ++y)
//	//	{
//	//		if (trimap.at<uchar>(y, x) == 0)
//	//			alpha.at<uchar>(y, x) = 0;
//	//		else if (trimap.at<uchar>(y, x) == 255)
//	//			alpha.at<uchar>(y, x) = 255;
//	//	}
//
//	//cv::imshow("GT04-alpha.png", alpha);
//	//finish = clock();
//	//cout << double(finish - start) / (CLOCKS_PER_SEC * 2.5) << endl;
//	//waitKey(0);
//	//return 0;
//}

#include <opencv2/core.hpp>
#include <opencv2/imgproc.hpp>
#include <opencv2/highgui.hpp>


cv::Mat element3(3, 3, CV_8U, cv::Scalar(1));
cv::Mat element5(5, 5, CV_8U, cv::Scalar(1));

cv::Mat cutGreenScreen(cv::Mat& src)
{
	cv::Mat srcCut, srcHSV, srcThreshold;
	srcCut = src;

	cvtColor(srcCut, srcHSV, CV_BGR2HSV_FULL);
	cvtColor(srcCut, srcThreshold, CV_BGR2GRAY);

	for (int i = 0; i < srcHSV.rows; i++)
	{
		cv::Vec3b* HSVpixel = srcHSV.ptr<cv::Vec3b>(i);
		uchar* GrayPixel = srcThreshold.ptr<uchar>(i);
		for (int j = 0; j < srcHSV.cols; j++)
		{
			if (HSVpixel[j][0] > 45 && HSVpixel[j][0] < 137 && HSVpixel[j][1] > 43 && HSVpixel[j][2] > 50)
			{
				GrayPixel[j] = 0;
			}
			else
			{
				GrayPixel[j] = 255;
			}
		}
	}	//裁剪绿幕

	dilate(srcThreshold, srcThreshold, element5);
	erode(srcThreshold, srcThreshold, element5);


	//RemoveSmallRegion(videoFrameThreshold, videoFrameThreshold, 20, 1, 0);


	blur(srcThreshold, srcThreshold, cv::Size(7, 7));
	threshold(srcThreshold, srcThreshold, 128, 255, cv::THRESH_BINARY);

	return srcThreshold;
}




int main()
{
	VideoCapture video = VideoCapture("D:\\QQFiles\\459533652\\FileRecv\\01.mp4");
	Mat stream;
	double rate = video.get(CV_CAP_PROP_FPS);
	/*获取视频帧的尺寸*/
	int width = video.get(CV_CAP_PROP_FRAME_WIDTH);
	int height = video.get(CV_CAP_PROP_FRAME_HEIGHT);
	cv::VideoWriter w_cap("D:\\re_video2.avi", CV_FOURCC('M', 'J', 'P', 'G'), rate, cv::Size(width, height));
	while(video.read(stream))
	{
		clock_t start = clock();
		Mat mask = cutGreenScreen(stream);
		Mat result;
		stream.copyTo(result, mask);
		clock_t finish = clock();
		cout << double(finish - start) / (CLOCKS_PER_SEC * 2.5) << endl;
		imshow("result", result);
		waitKey(10);
		w_cap.write(result);
	}
	return 0;
}